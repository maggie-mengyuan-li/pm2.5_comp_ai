---
title: "Soil analysis"
author: "Maggie Li (ml4424)"
date: "9/28/2021"
output: html_document
---

```{r load libraries}
library(tidyverse)
library(janitor)
library(stats)
library(lme4)
library(raster)
library(sf)
library(usmap)
library(tictoc)
require(lmerTest)
```


# Aim 1: Compare county-level Soil concentrations in 2000-2017 between AI and non-AI-populated counties

```{r read in file with county type defined for each 3109 study counties}
ai_county_fips = read_csv("data/ai_counties.csv") 
nai_county_fips = read_csv("data/nai_counties.csv") 
```

## Extract county-level Soil concentrations for 2000-2017

Data Source: Randall Martin's PM2.5 Model https://sites.wustl.edu/acag/datasets/surface-pm2-5/ 
Note: The raw data show the proportion of each component, so have to multiply it by the total PM concentration that year

For Vivian: The next 2 code chunks will take a while to run, especially looping through all years. If it's too much, you can run just one year or a few; the outputted datasets are already in the folders indicated by write_csv.

```{r read in US counties shapefile}
# read in all counties shapefile
counties_shp <- "data/cb_2018_us_county_500k/cb_2018_us_county_500k.shp"
all_counties <- st_read(counties_shp, stringsAsFactors = FALSE)

# group all_counties by state fips, exclude territories and hawaii and alaska
all_counties <- all_counties %>% arrange(STATEFP) %>%
  filter(STATEFP != "02",
         STATEFP != "15")
unique(all_counties$STATEFP)
all_counties

# each state's fips code in a vector
state_fips <- fips(state.name, county = c())

# remove hawaii and alaska (FIPS are 15 and 02)
state_fips <- state_fips[!(state_fips %in% c("02","15"))]

# save each state's counties as separate sf's, in a list. the function below will iterate through all of these states.
state_list <- list(length(state_fips)) # create list of length 48
for (i in 1:length(state_fips)){
  state_list[[i]] <- all_counties %>%
    filter(STATEFP==state_fips[i])
}
# state_list # each list value = one state; includes polygon counties in that state; 48 states total
```

Note: we have to extract concentrations in DC separately,  because DC was not a state in the state_list sf file.

```{r Extract DC data}
# Loop from 2001-2017
soil_years = c("dust_2000", "dust_2001","dust_2002", "dust_2003", "dust_2004", "dust_2005",
             "dust_2006", "dust_2007", "dust_2008", "dust_2009",
             "dust_2010", "dust_2011", "dust_2012", "dust_2013",
             "dust_2014", "dust_2015", "dust_2016", "dust_2017")

pm_years = c("pm_2000", "pm_2001", "pm_2002", "pm_2003", "pm_2004", "pm_2005",
             "pm_2006", "pm_2007", "pm_2008", "pm_2009",
             "pm_2010", "pm_2011", "pm_2012", "pm_2013",
             "pm_2014", "pm_2015", "pm_2016", "pm_2017")

# Extract Data for DC
## Note: we have to extract concentrations in DC separately,  because DC was not a state in the state_list sf file.
## create a df just DC all years, join with the existing components_year_df files in data/county_concentrations
DC_state_list <- all_counties %>%
    filter(STATEFP== "11")

# create empty list to save DC PM data into; (each list element is 1 df with one row, for the DC estimate that year.)
soil_dc_list = list()

# count variable for year to name saved out df
year = 2000
## Run loop for 2000 through 2017
for (i in 1:18){
  # read in ncdf as raster stack for soils
  soil_year = raster(paste("data/raw_components/soil/", soil_years[i], ".nc", sep = ""))
  soil_year = stack(soil_year)


  # read in ncdf as raster stack for total PM in 2001
  pm_year = raster(paste("data/raw_components/total_pm/", pm_years[i], ".nc", sep = ""))
  pm_year = stack(pm_year)

  # get the actual raster matrix for soil through multiplying percentage with total PM
  soil_actual_year = (soil_year*pm_year)/100
  mean(getValues(soil_actual_year), na.rm = T) # average county mean

# extract data for just DC (fips = 11)
  soil_dc_list[[i]] <- raster::extract(soil_actual_year,
                            DC_state_list,
                            fun=mean, na.rm=TRUE, df=TRUE) %>% # specify function = mean to extract mean concentrations
    mutate(year = year) %>%
    dplyr::rename(FIPS = ID) %>%
    dplyr::rename(soil = layer) %>%
    mutate(State = 11) %>%
    mutate(FIPS = 11001)
  soil_dc_list[[i]]$County <- "001"
  year = year + 1


}
toc()
soil_dc_list
soil_dc = do.call(rbind, soil_dc_list)
soil_dc
```

```{r combine all years into one df}
# Read in model data into list of length 19 (# study years)
soil_allyrs <- list()
yr = 2000
for (i in 1:18){
  soil_allyrs[[i]] <- read_csv(file = paste('data/county_concentrations/soil/dust_',
                                           yr, '_df.csv', sep = '')) %>%
    dplyr::rename(soil = layer) %>% # rename "layer" column to specify component (soil)
    mutate(year = yr) # add column for year
  yr <- yr + 1
}

soil_allyrs = do.call(rbind, soil_allyrs) # join list into one df
soil_allyrs
# UPDATE: join with DC data
soil_allyrs = soil_allyrs %>% dplyr::select(-ID)
soil_allyrs = rbind(soil_allyrs, soil_dc)

summary(soil_allyrs)
length(unique(soil_allyrs$FIPS))

# write out Final joined dataset w/ 48 states + DC
write_csv(soil_allyrs, "data/county_concentrations/allyrs/soil_allyrs.csv")

```

## Assign Soil estimates to AI vs non-AI counties

```{r join layer to AI county}
soil_allyrs = read_csv("data/county_concentrations/allyrs/soil_allyrs.csv")

all_county_types = rbind(ai_county_fips, nai_county_fips) %>% 
  rename(FIPS = County)

soil_ai_join = left_join(soil_allyrs, all_county_types) %>% 
  dplyr::select(FIPS, soil, year, county_type) %>% 
  rename(County = FIPS) %>% 
  mutate(county_type = replace_na(county_type, 1)) ## county FIPS 46102 is showing up as an NA
soil_ai_join
```

```{r join with covariates}
covariates = read_csv("data/covariates.csv")
summary(covariates)
soil_ai_join = soil_ai_join %>% 
  left_join(covariates)
soil_ai_join

# Compare summaries in all counties, AI, non-AI
summary(soil_ai_join)
summary(soil_ai_join %>% filter(county_type == 1))
summary(soil_ai_join %>% filter(county_type == 0))

# note higher median/mean levels in nAI counties (unadjusted)
```

```{r add columns for deciles}
# Split population density and hhincome into deciles for model
soil_ai_join$popd_q <- cut(soil_ai_join$pop_density, quantile(soil_ai_join$pop_density, seq(0,1,0.1)), include.lowest = TRUE)
soil_ai_join$hhinc_q <- cut(soil_ai_join$hh_income, quantile(soil_ai_join$hh_income, seq(0,1,0.1)), include.lowest = TRUE)
sum(table(soil_ai_join$popd_q, exclude = NULL)) == dim(soil_ai_join)[1]
soil_ai_join

  # set referent for df
soil_ai_join = soil_ai_join %>% 
  mutate(county_type = factor(county_type)) %>% 
  mutate(county_type = relevel(county_type, ref="0"))

## Save out dataframe 
write_csv(soil_ai_join,
          "data/county_concentrations/joined_dta/soil_ai_join.csv")
```
## Statistical Models:

```{r Run lmer models}
# unadjusted
soil_unadj = lmer(soil ~ county_type + as.factor(year) +
                    (1|State/County),
                  data = soil_ai_join)

## 95% CI: point estimate, LL, UL
paste(summary(soil_unadj)$coefficients[2,1] %>% round(digits = 3),
      " (",
      round(summary(soil_unadj)$coefficients[2,1] - 1.96*summary(soil_unadj)$coefficients[2,2], digits = 3),
      ", ",
      round(summary(soil_unadj)$coefficients[2,1] + 1.96*summary(soil_unadj)$coefficients[2,2], digits = 3),
      ")", sep = "")

# additionally adjusted for popd
soil_partial = lmer(soil ~ county_type + as.factor(year) +
                  popd_q +
                  (1|State/County),
                data = soil_ai_join)


## 95% CI: point estimate, LL, UL
paste(summary(soil_partial)$coefficients[2,1] %>% round(digits = 3),
      " (",
      round(summary(soil_partial)$coefficients[2,1] - 1.96*summary(soil_partial)$coefficients[2,2], digits = 3),
      ", ",
      round(summary(soil_partial)$coefficients[2,1] + 1.96*summary(soil_partial)$coefficients[2,2], digits = 3),
      ")", sep = "")

# full adj model
soil_full = lmer(soil ~ county_type + as.factor(year) +
                    popd_q + 
                    hhinc_q +
                    (1|State/County),
                  data = soil_ai_join, REML=FALSE)

## 95% CI: point estimate, LL, UL
paste(summary(soil_full)$coefficients[2,1] %>% round(digits = 2),
      " (",
      round(summary(soil_full)$coefficients[2,1] - 1.96*summary(soil_full)$coefficients[2,2], digits = 2),
      ", ",
      round(summary(soil_full)$coefficients[2,1] + 1.96*summary(soil_full)$coefficients[2,2], digits = 2),
      ")", sep = "")



# fully adjusted with interaction term for year
soil_full_interx = lmer(soil ~ county_type + as.factor(year) +
                    popd_q + 
                    hhinc_q +
                    county_type*as.factor(year) +
                    (1|State/County),
                  data = soil_ai_join, REML=FALSE)
summary(soil_full_interx)
```

```{r Save out results from main effects only model and interx effects model}

## save model output for main effects only model
saveRDS(soil_full,
        file = "intermediate/model_outputs/main_results/soil_main_effects.rds")
## save model output for main effects only model
saveRDS(soil_full_interx,
        file = "intermediate/model_outputs/main_results/soil_interx.rds")

```

```{r InterX plot from lmer}
# create vcov matrix of main effects and interX

# extract vcov matrix of the county type main effect and interaction effect for each categorical year
native_yr_vcov <- vcov(soil_full_interx)[c(2,seq(38,54)), c(2,seq(38,54))]

# calculate all the variances for all the years i.e. var(x+y); should be 19 total entries --> var_vector
# var_vector should be the same repeating value (from the diagonal of the vcov matrix above)
var_vector = c()
for (i in 2:18){
  var_vector[1] <- native_yr_vcov[1,1]
  var_vector[i] <- native_yr_vcov[1,1] + native_yr_vcov[i,i] + 2 * native_yr_vcov[i,1]
}
var_vector
sd_vector <- sqrt(var_vector)
length(sd_vector)
#matrix with 19 cols for 19 years, three rows: one for effect estimate of total effect per year (total effect = main effect + interx effect), one for CI lower, one for CI upper
soil_decline <- data.frame()
soil_decline[1,1] <- summary(soil_full_interx)$coefficients[2,1]
soil_decline[1,2] <- summary(soil_full_interx)$coefficients[2,1] - 1.96*sd_vector[1]
soil_decline[1,3] <- summary(soil_full_interx)$coefficients[2,1] + 1.96*sd_vector[1]

# fill in matrix thru loop for every following year
yr_ct <- 38
for (i in 2:18){
  soil_decline[i,1] <- summary(soil_full_interx)$coefficients[2,1]+
    summary(soil_full_interx)$coefficients[yr_ct,1]
  
  soil_decline[i,2] <- summary(soil_full_interx)$coefficients[2,1]+
    summary(soil_full_interx)$coefficients[yr_ct,1] - 1.96*sd_vector[i]
  
  soil_decline[i,3] <- summary(soil_full_interx)$coefficients[2,1]+
    summary(soil_full_interx)$coefficients[yr_ct,1] + 1.96*sd_vector[i]
  yr_ct <- yr_ct + 1
}

soil_decline

colnames(soil_decline) <- c('estimate', 'cl_lower', 'cl_upper') # set col names

soil_decline$year <- seq(2000, 2017) # column for year


#PLOT OF TOTAL EFFECT OF NATIVE OVER TIME; updated 12/14 to be consistent with Figure 3 layout (slanted x-axis label)
soil_interx_plot <- ggplot() + 
  theme_linedraw() + 
  geom_line(data = soil_decline,
            aes(x=year, y = estimate)) +
  geom_line(data=soil_decline,
            aes(x=year, y=cl_lower), linetype = "dashed") +
  geom_line(data=soil_decline,
            aes(x=year, y=cl_upper), linetype = "dashed") +
  ylim(-0.6, 0.6) +
  labs(x = "Year",
       y = expression(paste("Mean Difference in Mineral Dust (", mu, "g/", m^3, ")")),
       fill = "County Type") +
  theme(plot.title = element_text(size = 18),
        axis.title.y = element_text(size = 14),
        axis.text = element_text(size = 12),
        axis.title.x=element_blank(),
        panel.background = element_rect(fill='transparent'), 
        plot.background = element_rect(fill='transparent', color=NA)) +
  scale_x_continuous(breaks = seq(2000,2017,1), expand = c(0, 0)) +
  guides(x =  guide_axis(angle = 45)) +
  geom_hline(yintercept=0, linetype="solid", color = "red")
soil_interx_plot
# save out
ggsave("figures/effectmod_plots/main/soil.png", width = 6, height = 4, dpi = 300,
       bg='transparent')

```
### Smooth interX model with time
To Vivian: Given similarities with the linear models, we did not choose to include them in our paper, opting instead for the GLMM results above. You can run the below code to check it out if you wish to.

```{r 10 knots}
# # using splines
# library(splines)
# library(mgcv)
# library(gamm4)
# soil_full_interx_smooth = gamm4(soil ~ s(year, by = county_type, k = 10) + # specify k knots
#                     county_type +
#                       popd_q + 
#                     hhinc_q,
#                     random = ~(1|State/County),
#                   data =  soil_ai_join)
# summary(soil_full_interx_smooth)
# summary(soil_full_interx_smooth$gam)
# 
# plot(soil_full_interx_smooth$gam, pages = 1)
# 
# # empty df for predicted values from gam
# pdat = expand.grid(year = seq(2000, 2017, length = 170),
#                     county_type = c(0, 1),
#                    popd_q = "(160,382]",
#                    hhinc_q = "(4.45e+04,4.72e+04]")
# 
# 
# # add in predicted values from gam
# xp <- predict(soil_full_interx_smooth$gam, newdata = pdat, type = 'lpmatrix')
# xp
# 
# ## which cols of xp relate to splines of interest?
# c1 <- grepl('0', colnames(xp))
# c2 <- grepl('1', colnames(xp))
# ## which rows of xp relate to sites of interest?
# r1 <- with(pdat, county_type == '0')
# r2 <- with(pdat, county_type == '1')
# 
# ## difference rows of xp for data from comparison
# X <- xp[r1, ] - xp[r2, ]
# ## zero out cols of X related to splines for other lochs
# X[, ! (c1 | c2)] <- 0
# ## zero out the parametric cols
# X[, !grepl('^s\\(', colnames(xp))] <- 0
# #extract betas
# dif <- X %*% coef(soil_full_interx_smooth$gam)
# #extract se
# se <- sqrt(rowSums((X %*% vcov(soil_full_interx_smooth$gam)) * X))
# #calculate CI
# crit <- qt(.975, df.residual(soil_full_interx_smooth$gam))
# upr <- dif + (crit * se)
# lwr <- dif - (crit * se)
# 
# # function to do it all in 1
# smooth_diff <- function(model, newdata, f1, f2, var, alpha = 0.05,
#                         unconditional = FALSE) {
#     xp <- predict(model, newdata = newdata, type = 'lpmatrix')
#     c1 <- grepl(f1, colnames(xp))
#     c2 <- grepl(f2, colnames(xp))
#     r1 <- newdata[[var]] == f1
#     r2 <- newdata[[var]] == f2
#     ## difference rows of xp for data from comparison
#     X <- xp[r1, ] - xp[r2, ]
#     ## zero out cols of X related to splines for other lochs
#     X[, ! (c1 | c2)] <- 0
#     ## zero out the parametric cols
#     X[, !grepl('^s\\(', colnames(xp))] <- 0
#     dif <- X %*% coef(model)
#     se <- sqrt(rowSums((X %*% vcov(model, unconditional = unconditional)) * X))
#     crit <- qt(alpha/2, df.residual(model), lower.tail = FALSE)
#     upr <- dif + (crit * se)
#     lwr <- dif - (crit * se)
#     data.frame(pair = paste(f1, f2, sep = '-'),
#                diff = dif,
#                se = se,
#                upper = upr,
#                lower = lwr)
# }
# 
# comp_soil <- smooth_diff(soil_full_interx_smooth$gam, pdat, '1', '0', 'county_type')
# comp <- cbind(year = seq(2000, 2017, length = 170),
#               rbind(comp_soil))
# 
# comp
# 
# # plot smoothed difference
# ggplot(comp, aes(x = year, y = diff, group = pair)) +
#   theme_linedraw() +
#     geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
#     geom_line() +
#   # ylim(-0.61, 0.6) +
#   labs(x = "Year",
#        y = expression(paste("Mean Difference in Soil (", mu, "g/", m^3, ")")),
#        fill = "County Type") +
#   theme(plot.title = element_text(size = 18),
#         axis.title = element_text(size = 16),
#         axis.text = element_text(size = 12),
#         axis.title.x=element_blank()) +
#   scale_x_continuous(breaks = seq(2000,2017,1), expand = c(0, 0)) +
#   guides(x =  guide_axis(angle = 45)) +
#   geom_hline(yintercept=0, linetype="solid", color = "red")
# ggsave("figures/effectmod_plots/soil/soil_smooth_k10.png", width = 6, height = 4, dpi = 300)
# 
# # compare with original glmm
# soil_interx_plot
```

```{r 7 knots}
# # using splines
# library(splines)
# library(mgcv)
# library(gamm4)
# soil_full_interx_smooth = gamm4(soil ~ s(year, by = county_type, k = 7) + # specify k knots
#                     county_type +
#                       popd_q + 
#                     hhinc_q,
#                     random = ~(1|State/County),
#                   data =  soil_ai_join)
# summary(soil_full_interx_smooth)
# summary(soil_full_interx_smooth$gam)
# 
# plot(soil_full_interx_smooth$gam, pages = 1)
# 
# # empty df for predicted values from gam
# pdat = expand.grid(year = seq(2000, 2017, length = 170),
#                     county_type = c(0, 1),
#                    popd_q = "(160,382]",
#                    hhinc_q = "(4.45e+04,4.72e+04]")
# 
# 
# # add in predicted values from gam
# xp <- predict(soil_full_interx_smooth$gam, newdata = pdat, type = 'lpmatrix')
# xp
# 
# ## which cols of xp relate to splines of interest?
# c1 <- grepl('0', colnames(xp))
# c2 <- grepl('1', colnames(xp))
# ## which rows of xp relate to sites of interest?
# r1 <- with(pdat, county_type == '0')
# r2 <- with(pdat, county_type == '1')
# 
# ## difference rows of xp for data from comparison
# X <- xp[r1, ] - xp[r2, ]
# ## zero out cols of X related to splines for other lochs
# X[, ! (c1 | c2)] <- 0
# ## zero out the parametric cols
# X[, !grepl('^s\\(', colnames(xp))] <- 0
# #extract betas
# dif <- X %*% coef(soil_full_interx_smooth$gam)
# #extract se
# se <- sqrt(rowSums((X %*% vcov(soil_full_interx_smooth$gam)) * X))
# #calculate CI
# crit <- qt(.975, df.residual(soil_full_interx_smooth$gam))
# upr <- dif + (crit * se)
# lwr <- dif - (crit * se)
# 
# # function to do it all in 1
# smooth_diff <- function(model, newdata, f1, f2, var, alpha = 0.05,
#                         unconditional = FALSE) {
#     xp <- predict(model, newdata = newdata, type = 'lpmatrix')
#     c1 <- grepl(f1, colnames(xp))
#     c2 <- grepl(f2, colnames(xp))
#     r1 <- newdata[[var]] == f1
#     r2 <- newdata[[var]] == f2
#     ## difference rows of xp for data from comparison
#     X <- xp[r1, ] - xp[r2, ]
#     ## zero out cols of X related to splines for other lochs
#     X[, ! (c1 | c2)] <- 0
#     ## zero out the parametric cols
#     X[, !grepl('^s\\(', colnames(xp))] <- 0
#     dif <- X %*% coef(model)
#     se <- sqrt(rowSums((X %*% vcov(model, unconditional = unconditional)) * X))
#     crit <- qt(alpha/2, df.residual(model), lower.tail = FALSE)
#     upr <- dif + (crit * se)
#     lwr <- dif - (crit * se)
#     data.frame(pair = paste(f1, f2, sep = '-'),
#                diff = dif,
#                se = se,
#                upper = upr,
#                lower = lwr)
# }
# 
# comp_soil <- smooth_diff(soil_full_interx_smooth$gam, pdat, '1', '0', 'county_type')
# comp <- cbind(year = seq(2000, 2017, length = 170),
#               rbind(comp_soil))
# 
# comp
# 
# # plot smoothed difference
# ggplot(comp, aes(x = year, y = diff, group = pair)) +
#   theme_linedraw() +
#     geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
#     geom_line() +
#   # ylim(-0.61, 0.6) +
#   labs(x = "Year",
#        y = expression(paste("Mean Difference in Soil (", mu, "g/", m^3, ")")),
#        fill = "County Type") +
#   theme(plot.title = element_text(size = 18),
#         axis.title = element_text(size = 16),
#         axis.text = element_text(size = 12),
#         axis.title.x=element_blank()) +
#   scale_x_continuous(breaks = seq(2000,2017,1), expand = c(0, 0)) +
#   guides(x =  guide_axis(angle = 45)) +
#   geom_hline(yintercept=0, linetype="solid", color = "red")
# ggsave("figures/effectmod_plots/soil/soil_smooth_k7.png", width = 6, height = 4, dpi = 300)
# 
# # compare with original glmm
# soil_interx_plot
```

```{r 5 knots}
# # using splines
# library(splines)
# library(mgcv)
# library(gamm4)
# soil_full_interx_smooth = gamm4(soil ~ s(year, by = county_type, k = 5) + # specify k knots
#                     county_type +
#                       popd_q + 
#                     hhinc_q,
#                     random = ~(1|State/County),
#                   data =  soil_ai_join)
# summary(soil_full_interx_smooth)
# summary(soil_full_interx_smooth$gam)
# 
# plot(soil_full_interx_smooth$gam, pages = 1)
# 
# # empty df for predicted values from gam
# pdat = expand.grid(year = seq(2000, 2017, length = 170),
#                     county_type = c(0, 1),
#                    popd_q = "(160,382]",
#                    hhinc_q = "(4.45e+04,4.72e+04]")
# 
# 
# # add in predicted values from gam
# xp <- predict(soil_full_interx_smooth$gam, newdata = pdat, type = 'lpmatrix')
# xp
# 
# ## which cols of xp relate to splines of interest?
# c1 <- grepl('0', colnames(xp))
# c2 <- grepl('1', colnames(xp))
# ## which rows of xp relate to sites of interest?
# r1 <- with(pdat, county_type == '0')
# r2 <- with(pdat, county_type == '1')
# 
# ## difference rows of xp for data from comparison
# X <- xp[r1, ] - xp[r2, ]
# ## zero out cols of X related to splines for other lochs
# X[, ! (c1 | c2)] <- 0
# ## zero out the parametric cols
# X[, !grepl('^s\\(', colnames(xp))] <- 0
# #extract betas
# dif <- X %*% coef(soil_full_interx_smooth$gam)
# #extract se
# se <- sqrt(rowSums((X %*% vcov(soil_full_interx_smooth$gam)) * X))
# #calculate CI
# crit <- qt(.975, df.residual(soil_full_interx_smooth$gam))
# upr <- dif + (crit * se)
# lwr <- dif - (crit * se)
# 
# # function to do it all in 1
# smooth_diff <- function(model, newdata, f1, f2, var, alpha = 0.05,
#                         unconditional = TRUE) {
#     xp <- predict(model, newdata = newdata, type = 'lpmatrix')
#     c1 <- grepl(f1, colnames(xp))
#     c2 <- grepl(f2, colnames(xp))
#     r1 <- newdata[[var]] == f1
#     r2 <- newdata[[var]] == f2
#     ## difference rows of xp for data from comparison
#     X <- xp[r1, ] - xp[r2, ]
#     ## zero out cols of X related to splines for other lochs
#     X[, ! (c1 | c2)] <- 0
#     ## zero out the parametric cols
#     X[, !grepl('^s\\(', colnames(xp))] <- 0
#     dif <- X %*% coef(model)
#     se <- sqrt(rowSums((X %*% vcov(model, unconditional = unconditional)) * X))
#     crit <- qt(alpha/2, df.residual(model), lower.tail = FALSE)
#     upr <- dif + (crit * se)
#     lwr <- dif - (crit * se)
#     data.frame(pair = paste(f1, f2, sep = '-'),
#                diff = dif,
#                se = se,
#                upper = upr,
#                lower = lwr)
# }
# 
# comp_soil <- smooth_diff(soil_full_interx_smooth$gam, pdat, '1', '0', 'county_type')
# comp <- cbind(year = seq(2000, 2017, length = 170),
#               rbind(comp_soil))
# 
# comp
# 
# # plot smoothed difference
# ggplot(comp, aes(x = year, y = diff, group = pair)) +
#   theme_linedraw() +
#     geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
#     geom_line() +
#   # ylim(-0.61, 0.6) +
#   labs(x = "Year",
#        y = expression(paste("Mean Difference in Soil (", mu, "g/", m^3, ")")),
#        fill = "County Type") +
#   theme(plot.title = element_text(size = 18),
#         axis.title = element_text(size = 16),
#         axis.text = element_text(size = 12),
#         axis.title.x=element_blank()) +
#   scale_x_continuous(breaks = seq(2000,2017,1), expand = c(0, 0)) +
#   guides(x =  guide_axis(angle = 45)) +
#   geom_hline(yintercept=0, linetype="solid", color = "red")
# ggsave("figures/effectmod_plots/soil/soil_smooth_k5.png", width = 6, height = 4, dpi = 300)
# 
# # compare with original glmm
# soil_interx_plot
```

